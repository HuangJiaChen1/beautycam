import cv2
import mediapipe as mp
import numpy as np
import tkinter as tk
from tkinter import filedialog
from PIL import Image, ImageTk

from affine_transformation import warp_with_triangulation
from anti_faling import nasolabial_folds_filter
from anti_black import black_filter
from bg import bg_blur
from dayan import dayan
from dazui import dazui
from forehead import forehead
from long_nose import longnose
from meibai import apply_whitening_and_blend
from renzhong import renzhong
from shoulian import shoulian
from quangu import quangu
from zhailian import zhailian
from biyi import biyi
from res import enhance_face_detail
from white_eye import white_eyes
from white_teeth import white_teeth
from lipstick import lipstick as apply_lipstick
from blush import apply_blush
from zuijiao import zuijiao

mp_face_mesh = mp.solutions.face_mesh
mp_selfie_segmentation = mp.solutions.selfie_segmentation
EYE_INDICES = [374, 380, 390, 373, 249, 385, 384, 263, 466, 387, 386, 381, 382, 398, 388, 362, 154, 155, 33, 7, 246,
               161, 159, 158, 144, 145, 173, 133, 157, 163, 153, 160]
BOUNDARY = [270, 409, 317, 402, 81, 82, 91, 181, 37, 0, 84, 17, 269, 321, 375, 318, 324, 312, 311, 415, 308, 314, 61,
            146, 78, 95, 267, 13, 405, 178, 87, 185, 14, 88, 40, 291, 191, 310, 39, 80,
            4,
            334, 296, 276, 283, 293, 295, 285, 336, 282, 300, 46, 53, 66, 107, 52, 65, 63, 105, 70, 55,
            374, 380, 390, 373, 249, 385, 384, 263, 466, 387, 386, 381, 382, 398, 388, 362, 154, 155, 33, 7, 246, 161,
            159, 158, 144, 145, 173, 133, 157, 163, 153, 160,
            132, 58, 172, 136, 150, 149, 176, 148, 361, 288, 397, 365, 379, 378, 400, 377, 152,
            473, 468,
            116, 123, 345, 352, 103, 67,
            109, 10, 338, 297, 332, 126, 129, 98, 75, 166, 79, 239, 238, 20, 60, 355, 358, 327, 289, 392, 309, 459, 458,
            250, 290, 97, 2, 327, 326,
            48, 115, 220, 45, 275, 440, 344, 278, 280, 50, 389, 9, 162]
SHOULIAN_INDICES = [132, 58, 172, 136, 150, 149, 176, 148, 361, 288, 397, 365, 379, 378, 400, 377, 152, 389, 9, 162
    , 33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246,
                    263, 249, 390, 373, 374, 380, 381, 382, 362, 398, 384, 385, 386, 387, 388, 466]
DAYAN_DEFAULT = 1
SHOULIAN_DEFAULT = 1
QUANGU_DEFAULT = 1
ZHAILIAN_DEFAULT = 1
RENZHONG_DEFAILT = 0
BIYI_DEFAULT = 1
FOREHEAD_DEFAULT = 0
H_DEFAULT = 0
S_DEFAULT = 0
V_DEFAULT = 0
MOPI_DEFAULT = 0
FALING_DEFAULT = 0
BLACK_DEFAULT = 0
WHITE_EYE_DEFAULT = 1
WHITE_TEETH_DEFAULT = 1
LIPSTICK_DEFAULT = 0.0
BLUSH_DEFAULT = 0.0
LONGNOSE_DEFAULT = 0.0
ZUIJIAO_DEFAULT = 0.0
DAZUI_DEFAULT = 1
bg_blur_enabled = False

# Global variables to store inference results
cached_face_landmarks = None
cached_segmentation_mask = None
cached_image_shape = None
selected_faces = set()
face_params = {}
active_face = None
POINT_OFFSET = 500

all_params = ['DAYAN', 'SHOULIAN', 'QUANGU', 'ZHAILIAN', 'RENZHONG', 'BIYI', 'LONGNOSE', 'FOREHEAD', 'ZUIJIAO', 'DAZUI', 'S', 'V', 'MOPI', 'DETAIL', 'FALING', 'BLACK', 'WHITE_EYE', 'WHITE_TEETH', 'LIPSTICK', 'BLUSH']

defaults = {
    'DAYAN': DAYAN_DEFAULT,
    'SHOULIAN': SHOULIAN_DEFAULT,
    'QUANGU': QUANGU_DEFAULT,
    'ZHAILIAN': ZHAILIAN_DEFAULT,
    'RENZHONG': RENZHONG_DEFAILT,
    'BIYI': BIYI_DEFAULT,
    'LONGNOSE': LONGNOSE_DEFAULT,
    'FOREHEAD': FOREHEAD_DEFAULT,
    'ZUIJIAO': ZUIJIAO_DEFAULT,
    'DAZUI': DAZUI_DEFAULT,
    'S': S_DEFAULT,
    'V': V_DEFAULT,
    'MOPI': MOPI_DEFAULT,
    'DETAIL': 0.0,
    'FALING': FALING_DEFAULT,
    'BLACK': BLACK_DEFAULT,
    'WHITE_EYE': WHITE_EYE_DEFAULT,
    'WHITE_TEETH': WHITE_TEETH_DEFAULT,
    'LIPSTICK': LIPSTICK_DEFAULT,
    'BLUSH': BLUSH_DEFAULT,
}

def set_param(param, val):
    if active_face is not None:
        face_params[active_face][param] = val

def make_slider_command(param):
    def cmd(val):
        set_param(param, float(val))
        update_image()
    return cmd

def update_active_face(idx):
    global active_face
    active_face = idx
    active_label.config(text=f"Editing face {idx + 1}")
    for p, var in param_to_var.items():
        val = face_params[idx][p]
        var.set(val)


def get_points_all(landmarks, width, height):
    points = [(landmarks[i].x, landmarks[i].y, landmarks[i].z + 1) for i in range(len(landmarks))]
    points_pixels = [transform_to_3d(int(p[0] * width), int(p[1] * height), p[2]) for p in points]
    return points_pixels


def transform_to_3d(x, y, z):
    return (x * z, y * z, z)


def get_points_2D(landmarks, width, height):
    points = [(int(landmarks[i].x * width), int(landmarks[i].y * height)) for i in range(len(landmarks))]
    return points


def on_click(event):
    global selected_faces, face_params, active_face, cached_image_shape, cached_face_landmarks
    if cached_face_landmarks is None or len(cached_face_landmarks) == 0:
        return
    if cached_image_shape is None:
        return
    h, w = cached_image_shape[:2]
    cx, cy = event.x, event.y
    # First, check if click is inside any face convex hull
    found_inside = False
    for idx, lm in enumerate(cached_face_landmarks):
        all_2d = get_points_2D(lm.landmark, w, h)
        pts = np.array(all_2d, dtype=np.int32)
        if len(pts) < 3:
            continue
        hull = cv2.convexHull(pts)
        dist = cv2.pointPolygonTest(hull, (int(cx), int(cy)), False)
        if dist >= 0:
            found_inside = True
            if idx not in selected_faces:
                selected_faces.add(idx)
                face_params[idx] = {p: defaults[p] for p in all_params}
            update_active_face(idx)
            update_image()
            return
    if not found_inside:
        min_dist = float('inf')
        closest_idx = -1
        for idx, lm in enumerate(cached_face_landmarks):
            nose_x = int(lm.landmark[1].x * w)
            nose_y = int(lm.landmark[1].y * h)
            dist = np.sqrt((cx - nose_x)**2 + (cy - nose_y)**2)
            if dist < min_dist:
                min_dist = dist
                closest_idx = idx
        if min_dist < 100:
            if closest_idx not in selected_faces:
                selected_faces.add(closest_idx)
                face_params[closest_idx] = {p: defaults[p] for p in all_params}
            update_active_face(closest_idx)
            update_image()


def run_model_inference(image):
    """Run both face mesh and selfie segmentation models once per image"""
    global cached_face_landmarks, cached_segmentation_mask, cached_image_shape

    if image is None:
        print("Error: Input image is None.")
        return None, None

    cached_image_shape = image.shape

    # Run face mesh inference with multiple faces
    with mp_face_mesh.FaceMesh(
            static_image_mode=True,
            max_num_faces=5,
            refine_landmarks=True,
            min_detection_confidence=0.5) as face_mesh:

        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        face_results = face_mesh.process(image_rgb)

